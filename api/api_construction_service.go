/*
 * Rosetta
 *
 * A standard for blockchain interaction
 *
 * API version: 1.2.3
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"context"
	"math/big"

	"github.com/celo-org/rosetta/celo"
	"github.com/celo-org/rosetta/celo/client"
	"github.com/ethereum/go-ethereum/common"
)

// ConstructionApiService is a service that implents the logic for the ConstructionApiServicer
// This service should implement the business logic for every endpoint for the ConstructionApi API.
// Include any external packages or services that will be required by this service.
type ConstructionApiService struct {
	celoClient  *client.CeloClient
	chainParams *celo.ChainParameters
}

// NewConstructionApiService creates a default api service
func NewConstructionApiService(celoClient *client.CeloClient, chainParams *celo.ChainParameters) ConstructionApiServicer {
	return &ConstructionApiService{
		celoClient:  celoClient,
		chainParams: chainParams,
	}
}

func (s *ConstructionApiService) getTxMetadata(ctx context.Context, address common.Address) (*TransactionMetadata, error) {
	var txMetadata TransactionMetadata
	var err error

	txMetadata.Nonce, err = s.celoClient.Eth.NonceAt(ctx, address, nil) // nil == latest
	if err != nil {
		return nil, client.WrapRpcError(err)
	}

	txMetadata.GatewayFeeRecipient, err = s.celoClient.Eth.Coinbase(ctx)
	if err != nil {
		return nil, client.WrapRpcError(err)
	}

	txMetadata.GasPrice, err = s.celoClient.Eth.SuggestGasPrice(ctx)
	if err != nil {
		return nil, client.WrapRpcError(err)
	}

	// TODO: consider fetching from node
	txMetadata.GatewayFee = big.NewInt(0)

	return &txMetadata, nil
}

// TransactionConstruction - Get Transaction Construction Metadata
func (s *ConstructionApiService) TransactionConstruction(ctx context.Context, txConstructionRequest TransactionConstructionRequest) (interface{}, error) {
	err := ValidateNetworkId(&txConstructionRequest.NetworkIdentifier, s.chainParams)
	if err != nil {
		return nil, err
	}
	address := common.HexToAddress(txConstructionRequest.AccountIdentifier.Address)

	var metadata = make(map[string]interface{})

	txMetadata, err := s.getTxMetadata(ctx, address)
	if err != nil {
		return nil, WrapError("GetTxData", err)
	}

	switch txConstructionRequest.Method {
	case TransferMethod:
		balance, err := s.celoClient.Eth.BalanceAt(ctx, address, nil) // nil == latest
		if err != nil {
			return nil, WrapError("Transfer: BalanceAt", err)
		}

		msg := txMetadata.asMessage()
		msg.Value = balance
		msg.To = &DummyAddress
		gasLimit, err := s.celoClient.Eth.EstimateGas(ctx, *msg)
		if err != nil {
			return nil, WrapError("Transfer: EstimateGas", err)
		}

		txMetadata.GasLimit = gasLimit

		metadata[TransferMethod] = TransferMetadata{
			Balance: balance,
			Tx:      txMetadata,
		}

	default:
		return nil, WrapError("Unknown method", err)
	}

	response := TransactionConstructionResponse{
		SuggestedFee: Amount{
			Value:    txMetadata.GasPrice.String(),
			Currency: CeloGold,
		},
		Metadata: metadata,
	}
	return response, nil
}

// TransactionSubmit - Submit a Signed Transaction
func (s *ConstructionApiService) TransactionSubmit(ctx context.Context, transactionSubmitRequest TransactionSubmitRequest) (interface{}, error) {
	txhash, err := s.celoClient.Eth.SendRawTransaction(ctx, []byte(transactionSubmitRequest.SignedTransaction))
	if err != nil {
		return nil, client.WrapRpcError(err)
	}

	response := TransactionSubmitResponse{
		TransactionIdentifier: TransactionIdentifier{
			Hash: txhash.String(),
		},
		Status:   SubmissionSuccess.String(),
		Metadata: map[string]interface{}{},
	}
	return response, nil
}
