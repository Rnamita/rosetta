/*
 * Rosetta
 *
 * A standard for blockchain interaction
 *
 * API version: 1.2.3
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package api

import (
	"context"
	"errors"
	"fmt"
	"math/big"

	"github.com/celo-org/rosetta/celo"
	"github.com/celo-org/rosetta/celo/client"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
)

// ConstructionApiService is a service that implents the logic for the ConstructionApiServicer
// This service should implement the business logic for every endpoint for the ConstructionApi API.
// Include any external packages or services that will be required by this service.
type ConstructionApiService struct {
	celoClient  *client.CeloClient
	chainParams *celo.ChainParameters
}

// NewConstructionApiService creates a default api service
func NewConstructionApiService(celoClient *client.CeloClient, chainParams *celo.ChainParameters) ConstructionApiServicer {
	return &ConstructionApiService{
		celoClient:  celoClient,
		chainParams: chainParams,
	}
}

func (s *ConstructionApiService) getTxdata(ctx context.Context, address common.Address) (*types.Txdata, error) {
	var txData types.Txdata
	var err error
	txData.AccountNonce, err = s.celoClient.Eth.NonceAt(ctx, address, nil) // nil == latest
	if err != nil {
		return nil, err
	}

	txData.GatewayFeeRecipient, err = s.celoClient.Eth.Coinbase(ctx)
	if err != nil {
		return nil, err
	}

	txData.Price, err = s.celoClient.Eth.SuggestGasPrice(ctx)
	if err != nil {
		return nil, err
	}

	// TODO: consider fetching from node
	txData.GatewayFee = big.NewInt(0)

	return &txData, nil
}

// TransactionConstruction - Get Transaction Construction Metadata
func (s *ConstructionApiService) TransactionConstruction(ctx context.Context, txConstructionRequest TransactionConstructionRequest) (interface{}, error) {
	err := ValidateNetworkId(&txConstructionRequest.NetworkIdentifier, s.chainParams)
	if err != nil {
		return BuildErrorResponse(1, err), nil
	}
	address := common.HexToAddress(txConstructionRequest.AccountIdentifier.Address)

	var metadata = make(map[string]interface{})

	txdata, err := s.getTxdata(ctx, address)
	if err != nil {
		return BuildErrorResponse(2, err), nil
	}

	switch txConstructionRequest.Method {
	case TransferMethod:
		balance, err := s.celoClient.Eth.BalanceAt(ctx, address, nil) // nil == latest
		if err != nil {
			return BuildErrorResponse(3, err), nil
		}
		metadata[TransferMethod] = TransferMetadata{
			Balance: balance,
			Txdata:  txdata,
		}
	default:
		return BuildErrorResponse(4, fmt.Errorf("Method not supported: %s", txConstructionRequest.Method)), nil
	}

	response := TransactionConstructionResponse{
		// TODO: compute suggested fee with more sophistication
		SuggestedFee: Amount{
			Value:    GasUpperBound[txConstructionRequest.Method],
			Currency: CeloGold,
		},
		Metadata: metadata,
	}
	return response, nil
}

// TransactionSubmit - Submit a Signed Transaction
func (s *ConstructionApiService) TransactionSubmit(ctx context.Context, transactionSubmitRequest TransactionSubmitRequest) (interface{}, error) {
	// TODO - update TransactionSubmit with the required logic for this service method.
	// Add api_construction_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.
	return nil, errors.New("service method 'TransactionSubmit' not implemented")
}
